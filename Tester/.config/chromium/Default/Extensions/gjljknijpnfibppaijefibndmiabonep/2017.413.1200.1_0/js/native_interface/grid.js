/*
 * Copyright (c) 2014-2015 NVIDIA CORPORATION.  All Rights Reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 *
 */

/*!
 * \file grid.js
 * \brief Defines the client UI interface to access the functionalities of the
 * NVIDIA GRID Chrome Client between the JavaScript code and the Native Client module's C or C++ code.
 */

/*! \brief descriptin of JSON object sent from GridPepperModule
var JsonObj = {
    //  invoked when the NVbClient's status has changed during the loading process.
    //  keys to current load status messages
    //  The tokens are sent in order below to update the progression of starting a game session.
    "loadevent" = {
        "connecting",//  "Connecting you to the Nvidia Geforce GRID."
        "queue_position",//  "Queue Position Updated."
        "configuring",//  "Game Seat Configuration."
        "game_seat_ready.",//  "Game Seat is Ready."
        "playing"//  "You are playing on the Nvidia Geforce GRID."
    },
    //  current queue position
    "queueposition" = {
        queuePosition //  position of the Session in the Queue. A value of ~0 means no queue position estimate available.
    }
    //  invoked when the NVbClient's status has changed during streaming.
    "streamevent" = {
        "nvb_evt_game_connected",//  "Game is playing, and has started streaming."
        "nvb_evt_streaming_server_pause",/*! "Game paused on server. Hold on till the game on the server resumes."
        "nvb_evt_streaming_server_resume",/*! "Game resuming on the server."
        "nvb_evt_streaming_quality_changed",/*! "The computed quality of streaming changed."
        "nvb_evt_game_exited_by_user",//  The user has voluntarily exited from within the game.
        "nvb_evt_game_exited_unintentionally",//  A playing game has exited unexpectedly.
        "nvb_evt_session_expired",//  The game has been played for too long.
        "nvb_evt_network_connection_error",//   A network error (probably connection lost) occurred during streaming.
        "nvb_r_network_error",//  A network error has occurred."
        "nvb_r_user_is_not_entitled",//  User is not entitled to access the specified resource. This is an umbrella
                                                   error code for entitlement failures.
        "nvb_evt_game_exited_due_to_user_idle_timeout",//  Inactivity timeout has been reached, and the user has been
                                                              disconnected.
        "nvb_evt_error_unknown",//  An unknown error has occurred
        "nvb_r_version_mismatch",//  Client is not compatible with one of the remote servers,
                                                   and MUST be upgraded.
        "nvb_r_upgrade_recommended",//  Upgrading the client to a later version is recommended.
        "gpm_null_message_loop",//  Message Loop is null!
        "unknown_stream_command",//  Unknown stream command
        "gpm_postwork_failed",//  Unable to postwork to message loop
        "parsing_failed",//  Parsing stream command failed
        "nvb_getgamelist_failed",//  nvbGetGameList failed
        "nvb_play_failed",//  nvbPlay failed
        "retrying",//  "Connection error...Retrying..."
        "no_applications_for_user",//  "no game titles available for the user"
        "nvb_registercallbacks_failed",//  nvbRegisterCallbacks failed
        "nvb_initialize_failed",//  Initialize client failed
        "getapplist_failed",//  getAppList Failed
        "nvb_setauthinfo_failed",//  getAppList Success
        "mouse_lock_changed",//mouse state changed
        "nvb_r_session_request_rejected",//Client request was rejected by the server
        "nvb_r_remote_user_response_timeout", //Server did not respond to the client request within max wait limit
        "nvb_summary_stats", //Summary statistics information
        <nvbEnumToString in lower case>,//  The event rest of events that are not handled in GridPepperModule
        "nvb_stop_failed", // nvbstop failed
    },
    //  invoked when a log message containing english text is generated by the GRID Pepper Module.
    "logevent" = {
        <logs>
    },
    //  invoked when the GRID Pepper Module has responsed to the command.
    "commandresponseevent" = {
        "initialize_completed",      // Initialize client completed
        "getapplist_success",        // getAppList Success
        "network_capability_result", // Network capability result
        "play_completed",            // Game start succeeded
        "stop_completed",            // Game stop succeeded
        "registercallbacks_completed", // Register callback succeeded
        "setauthinfo_completed",       // Set AuthInfo succeeded
        "reconnect_completed",         // pause and resume asynchronous API's returned success.
    },
    // format of the application list returned by the server
    "applist" = [{
        "gameid",                               // "Short Name" Game identifier
        "appid",                                // Application identifier for the game title
        "internaltitle",                        // Human-friendly string of the game
        "imageasset":[{                         // Image asset description
                        "imageassetsubtype",    // Description indicating use, for e.g it indicates whether this asset is a box art, screenshoot, etc
                        "imageasseturl",        // URL of asset on server
                        "imagename",            // Name of image
                        "imagewidth",           // Width of the image
                        "imageheight",          // Height of the image
                        "imagemouseovertext",   // Text to display when hovering over image
                      },...],
    },...],
    "networkcapabilityresult" = {
        "testResult",                // optimal, sufficient, insufficient or error
        "bandwidthMeasured",         // Measured bandwidth in b/s
        "bandwidthRequired",         // Minimum tolerable bandwidth required for streaming in b/s
        "bandwidthRecommended",      // Recommended bandwidth for streaming in b/s
        "frameLossMeasured",         // Measured how many frames were lost/dropped in %
        "frameLossRequired",         // Maximum tolerable frame loss required for streaming expressed as a %
        "frameLossRecommended",      // Recommended frame loss for streaming expressed as a %
        "jitterMeasured",            // The 99th percentile of the measured jitter with the concept of frames in ms
        "jitterRequired",            // Maximum tolerable 99th percentile frame jitter required for streaming in ms
        "jitterRecommended",         // Recommended 99th percentile frame jitter for streaming in ms
        "latencyMeasured",           // Measured latency ms (UDP RTT)
        "latencyRequired",           // Maximum tolerable (UDP RTT) latency required for streaming in ms
        "latencyRecommended",        // Recommended latency for streaming in ms
    },
};
*/

var GRID = (function () {
    /*! \brief interface storing references to UI callback functions. */
    var _listener = {
        /*!
         * \brief
         * invoked when the NVbClient's status has changed during the loading process.
         * \param event The event itself.
         */
        onLoadEvent: function(event) {},
        /*!
         * \brief
         * invoked when position of the session in the queue is updated during the loading process.
         * \param queuePosition position of the Session in the Queue.
         * \note  A value of ~0 means no queue position estimate available.
         */
        onQueuePositionChanged: function (queuePosition) {},
        /*!
         * \brief
         * invoked when the NVbClient's status has changed during streaming.
         * \param jsonobj The JSON object of the event.
         */
        onStreamEvent: function (jsonobj) {},
        /*!
         * \brief
         * invoked when the GRID Pepper Module's initialized.
         */
        onInitialized: function() {},
        /*!
         * \brief
         * invoked when a log message containing english text is generated by the GRID Pepper Module.
         * \param message The text of the log message itself.
         */
        onLog: function(message) {},
        /*!
         * \brief
         * invoked when application list is returned.
         * \param jsonobj The JSON object containing the application list.
         */
        onAppListSuccess: function(jsonobj) {},
        /*!
         * \brief
         * invoked when the network capability test is done.
         * \param jsonobj The JSON object which has the network capability test result.
         */
        onNetworkCapabilityResult: function(jsonobj) {},
        /*!
         * \brief
         * invoked when an exception occurs
         * \param jsonobj The JSON object which has backtrace.
         */
        onException: function(jsonobj) {}
    };
    /*! \brief The default value of a collection of things to configure by user or by javascript */
    var _streamerConfig = {
        "address": "",/*!< zone address */
        "port": 443,/*!< port number */
        "userid": "",/*!< user ID */
        "xres": 1280,/*!< screen resolution width */
        "yres": 720,/*!< screen resolution height */
        "onscreenstats": false,/*!< if on screen stats is enabled */
        "serverstats": true,/*!< if server side stats is enabled */
        "decodetype": 2,/*!< type of decode to use. 0 - ChromeHW, 1 - ChromeSW, 2 - NaclPortsSW, 3 - Auto Detect*/
        "multithreaddecode": true,/*!< if multithreaded decoding is enabled */
        "sessionid": "" ,/*!< current session ID GUID */
        "framerate": 30,/*!< desired framerate, 0 = use server default or (range of 10 to 60) */
        "bitrate": 5,/*!< desired bit rate in kbps.  0 = use server default or (range of 1000 to 240000) */
        "jsdebuglevel": 1,/*!< desired javascript debug level, 0 = print all the log to javascript console(range of 0 to 4),
                               1 = ingnore debug prints */
        "termdebuglevel": 4,/*!< desired terminal debug level, 0 = print all the log to terminal console(range of 0 to 4) */
        "gaming": true,/*!< if the GRID Pepper Module will be initialized into gaming profile */
        "certificate": "",/*!< certificate needed for co-play scenario */
        "privateKey": "",/*!< privatekey needed for co-play scenario */
        "servercertificatehash":"", //server's certificate hash which will be used to validate the server
        "persistentstoragesize":0, //size of the persistent storage area requested by the JS side
        "authtype":"none", //type of auth used by the server
        "googleanalyticstracking":true, //whether to allow google analytics tracking
        "analyticscode":"", //google analytics code, unique for a particular account
        "analyticsservice":"", //name of the google analytics service
        "useextendedaudiobuffer": false, /*!< Use larger buffer for audio rendering, this is required for win 10 platform. */
        "codectype" : 0 /* Codec Type. */
    };
    /*! \brief The default configuration for application start */
    var _startConfig = {
        "appid": 0,         /*!< the application ID to launch */
        "gameid": "",       /*!< the game ID to launch */
        /* NOTE: gameid is present for legacy reasons, it will be removed soon.
                 It is advisable to pass appid, but if a system does not support appid then pass the gameid */
    };
    /*! \brief Time at which initialize was called. */
    var _onInitTime = null;
    /*! \brief Time at which streaming started. */
    var _streamingStartTime = null;
    /*! \brief Time at which streaming exited. */
    var _streamingEndTime = null;
    /*! \brief keeps track of whether gamepad event was received*/
    var _gamepadEventReceived = false;
    /*! \brief This gives an approximate count of the number of frames received. */
    var _summaryStatsCount = 0;
    /*! \brief This gives the frame rate initialized by the client. */
    var _frameRate = _streamerConfig.framerate;
    /*! \brief These are used to store the CPU usage. */
    var _cpuUsageUsed = [0];
    var _cpuUsageTotal = [0];
    var _reconnectIssued = false;
    
    var GA_CUSTOM_DIMENSION_TYPE = "ga_custom_dimension";

    /*!
     * Deprecated.
     * \brief
     * getter of the default streamerconfig
     */
    function pDefaultStreamerConfig() {
        return _streamerConfig;
    }
    /*!
     * \brief
     * getter of the default startConfig
     */
    function pDefaultStartConfig() {
        return _startConfig;
    }
    /*!
     * \brief
     * getter of the default initialize config
     */
    function pDefaultInitializeConfig() {
        return _streamerConfig;
    }
    /*!
     * \brief
     * handle of the GRID Pepper Module when it is initialized
     */
    var _gridPepperModule = null;
    /*!
     * \brief
     * variable which keeps track of whether a request is in progress
     */
    var _isRequestInProgress = false;
    /*!
     * \brief
     * private methods forwarding the log from GRID Pepper Module to the UI
     * \param message the log message itself
     */
    function _log(message) {
        _listener.onLog(message);
    }
    /*!
     * \brief
     * handling load event update from GRID Pepper Module,
     * invoked when the NVbClient's status has changed during the loading process.
     * \param jsonobj the event itself.
     */
    function _updateLoadEventStatus(jsonobj) {
        if (jsonobj.loadevent) {
            _log("load event :     " + JSON.stringify(jsonobj));
            var loadstatus = jsonobj.loadevent;
            _listener.onLoadEvent(loadstatus);
            if (loadstatus.localeCompare("queueposition") == 0) {
                if (jsonobj.queueposition) {
                    _listener.onQueuePositionChanged(jsonobj.queueposition);
                } else {
                    _log("Error: Queue position not available in the received loadstatus message from client ");
                }
            }
        }
    }

    // Function to compute CPU usage. It samples data, stores them, and in the next call it uses
    // previously stored sample and currently obtained sample to calculate the load.
    // The first print will always be useless since there is no data to compare against.
    function _computeAndPrintCPUUsage() {
        PLATFORM.getCPUInfo(function(cpuinfo) {
            numCPU = cpuinfo.processors.length;
            perCoreUsage = "";
            load = 0.0;
            avgLoad = 0.0;

            for (i = 0; i < numCPU; i++) {
                cpuI = cpuinfo.processors[i].usage;

                currentUsage = cpuI.user + cpuI.kernel;
                currentTotal = cpuI.total;

                load = (currentUsage - _cpuUsageUsed[i]) * 100 / (currentTotal - _cpuUsageTotal[i]);
                avgLoad += load;

                perCoreUsage += "CPU" + (i + 1) + ": " + (load.toFixed(2)) + " ";

                _cpuUsageUsed[i] = currentUsage;
                _cpuUsageTotal[i] = currentTotal;
            }

            avgLoad /= numCPU;
            logString = "AvgCPU: " + avgLoad.toFixed(2) + " " + perCoreUsage;
            _log(logString);
        });
    }

    /*!
     * \brief
     * handling stream event update from GRID Pepper Module,
     * invoked when the NVbClient's status has changed during streaming.
     * \param jsonobj the event itself.
     */
    function _updateStreamEventStatus(jsonobj) {
        //Don't log stats, might impact the performance
        if(jsonobj.streamevent == "nvb_summary_stats")
        {
            _summaryStatsCount++;

            //Sending RTD data will be handled by the background script
            PLATFORM.sendMessage({
                type: 'rtd',
                msg: jsonobj.roundTripDelayMs
            });

            if (_summaryStatsCount % 5 == 0)
                _computeAndPrintCPUUsage();
        }
        else if (jsonobj.streamevent != "nvb_evt_streaming_quality_changed")
        {
            _log("streamer event is: " + JSON.stringify(jsonobj));
        }


        if(jsonobj.streamevent == "network_area_type") {
            PLATFORM.sendMessage({
                type: GA_CUSTOM_DIMENSION_TYPE,
                data: { networkareatype : jsonobj.eventdata }
            });
        } else if( jsonobj.streamevent == "server_version") {
            PLATFORM.sendMessage({
                type: GA_CUSTOM_DIMENSION_TYPE,
                data: { serverversion : jsonobj.eventdata }
            });  
        } else if (jsonobj.streamevent == "codec_type") {
            // Do not send any event to UI for now.
            // Ignore this event as adding this requires changes to coplay clients.
        } else {
            if(jsonobj.streamevent.localeCompare("nvb_evt_controller_mapping_changed") == 0) {
                //background script will track the time taken in each mapping and send the data to GA
                PLATFORM.sendMessage({
                    type: 'controller_mapping_changed',
                    msg: jsonobj.eventdata
                });
            } else if(jsonobj.streamevent.localeCompare("nvb_evt_game_connected") == 0) {
                if(!_reconnectIssued) {
                    _streamingStartTime = new Date();
                }
            }

            //Send data to google analytics
            _sendDataToGoogleAnalytics(jsonobj);

            /* check if (jsonobj.eventdata ==0) - in that case we may need additional processing */
            _listener.onStreamEvent(jsonobj);
        }
    }
    /*!
     * \brief
     * Send network information to google analytics
     */
    function _sendNetworkInfoToGoogleAnalytics()
    {
        if(window.navigator.connection) {
            sendGAEventMessage("Network Information", "Network Type", "network_type_"+window.navigator.connection.type, 0);
            window.navigator.connection.addEventListener('typechange', _sendNetworkInfoToGoogleAnalytics);
        } else {
            _log("Network api not supported by browser");
        }
    }
    
    /*!
     * \brief
     * Send system information to google analytics
     */
    function _sendSystemInfoToAsyncService()
    {
        PLATFORM.getCPUInfo(function(cpuinfo) {
            var cpuInfoObj = {
                cpumodel: "",
                noofprocessors: 0,
            }
            
            cpuInfoObj.cpumodel = cpuinfo.modelName;
            cpuInfoObj.noofprocessors = cpuinfo.numOfProcessors;
            
            PLATFORM.sendMessage({
                type: 'system_info',
                data: cpuInfoObj
            });

            _log(JSON.stringify(cpuinfo));
        });
        
        try {
            var gpuInfo = {
                glvendor: "",
                glrenderer: "",
                glversion: "",
            }
            
            //Send GPU information
            var gl = document.createElement('canvas').getContext('experimental-webgl');
            gpuInfo.glversion = gl.getParameter(gl.VERSION);

            var extension = gl.getExtension('WEBGL_debug_renderer_info');
            if (extension != undefined) {
                gpuInfo.glrenderer = gl.getParameter(extension.UNMASKED_RENDERER_WEBGL);
                _log("GL Renderer: " + gpuInfo.glrenderer);
                gpuInfo.glvendor = gl.getParameter(extension.UNMASKED_VENDOR_WEBGL);
                _log("GL Vendor: " + gpuInfo.glvendor);
            }
            
            PLATFORM.sendMessage({
                type: 'system_info',
                data: gpuInfo
            });
        } catch (err) {
            consoleLog("Cannot send GPU info to GA, error: " + err);
        }
    }

    /*!
     * \brief
     * Send OS, Chrome version, DVS Changelist information to google analytics
     */
    function _sendMiscInfoToGoogleAnalytics()
    {
        //Send OS information
        PLATFORM.getOSInfo(function(platforminfo) {
            sendGAEventMessage("OS", platforminfo.os, "NA", 0);
        });

        //Send chrome browser version
        var appVersion = window.navigator.appVersion;
        var versionArray = appVersion.split(" ");
        var chromeVersionStr;

        for(var i = 0; i < versionArray.length; i++) {
            if(versionArray[i].indexOf("Chrome") > -1) {
                chromeVersionStr = versionArray[i];
                break;
            }
        }

        if(chromeVersionStr) {
            var chromeVersionArray = chromeVersionStr.split("/");
            if(chromeVersionArray.length == 2) {
                sendGAEventMessage("Chrome Version", chromeVersionArray[1], "NA", 0);
            }
        }

        //Send DVS changelist
        if(typeof dvs_changelist != 'undefined') {
            PLATFORM.sendMessage({
                type: GA_CUSTOM_DIMENSION_TYPE,
                data: { dvschangelist : dvs_changelist }
            });  
        }
    }
    
    /*!
     * \brief
     * Send data to google analytics
     * \param jsonobj streaming event data.
     */
    function _sendDataToGoogleAnalytics(jsonobj) {
        var gacategory = "JavaScript Calls";
        var gaaction;
        var galabel = jsonobj.eventdata;
        if(typeof galabel != 'undefined' && typeof galabel == 'string') {
            galabel = galabel.toLowerCase();
        }
        var gavalue = 0;
        var sendgadata = true;

        if ((jsonobj.streamevent.localeCompare("nvb_initialize_failed") == 0) || (jsonobj.streamevent.localeCompare("nvb_r_upgrade_recommended") == 0) || (jsonobj.streamevent.localeCompare("nvb_r_version_mismatch") == 0)) {
            gaaction = "pInitialize";
        } else if (jsonobj.streamevent.localeCompare("nvb_setauthinfo_failed") == 0) {
            gaaction = "pSetAuthInfo";
        } else if (jsonobj.streamevent.localeCompare("nvb_registercallbacks_failed") == 0) {
            gaaction = "pRegisterCallbacks";
        }else if (jsonobj.streamevent.localeCompare("getapplist_failed") == 0) {
            gaaction = "pGetAppList";
        } else if (jsonobj.streamevent.localeCompare("nvb_play_failed") == 0) {
            gaaction = "pStart";
        } else if (jsonobj.streamevent.localeCompare("nvb_stop_failed") == 0) {
            gaaction = "pStop";
        } else if (jsonobj.streamevent.localeCompare("nvb_reconnect_failed") == 0) {
            gaaction = "pReconnect";
        } else if((jsonobj.streamevent.localeCompare("nvb_evt_streaming_quality_changed") == 0) && (jsonobj.senddatatogoogleanalytics == 1)) {
            gacategory = "Streaming";
            gaaction = "QOS Score";
            gavalue = parseInt(jsonobj.eventdata);

            if(gavalue <= 100 && gavalue > 80) {
                galabel = "QOS Score 5 - Excellent";
            } else if(gavalue > 60) {
                galabel = "QOS Score 4 - Good";
            } else if(gavalue > 40) {
                galabel = "QOS Score 3 - Average";
            } else if(gavalue > 20) {
                galabel = "QOS Score 2 - Poor";
            } else {
                galabel = "QOS Score 1 - Worst";
            }
        } else if(jsonobj.streamevent.localeCompare("gamepad_state_changed") == 0) {
            _gamepadEventReceived = true;
            gacategory = "Streaming";
            gaaction = "Gamepad";

            if(jsonobj.eventdata >= 0) {
                galabel = "Gamepad(s) Connected " + jsonobj.eventdata;
            } else {
                galabel = "";
            }
        } else if(jsonobj.streamevent.localeCompare("initialize_opengl_error_title") == 0 || jsonobj.streamevent.localeCompare("initialize_decoder_error_title") == 0) {
            gacategory = "JavaScript Calls";
            gaaction = "pInitialize";
            galabel = jsonobj.streamevent;
        } else if(jsonobj.senddatatogoogleanalytics && jsonobj.senddatatogoogleanalytics == 1) {
            gacategory = "Streaming";

            if((jsonobj.streamevent.localeCompare("nvb_evt_game_connected") == 0) || (jsonobj.streamevent.localeCompare("nvb_evt_game_start_failed") == 0) || (jsonobj.streamevent.localeCompare("nvb_evt_streaming_server_pause") == 0) || (jsonobj.streamevent.localeCompare("nvb_evt_streaming_server_resume") == 0)) {
                if(_reconnectIssued && ((jsonobj.streamevent.localeCompare("nvb_evt_game_connected") == 0) || (jsonobj.streamevent.localeCompare("nvb_evt_game_start_failed") == 0))) {
                    gaaction = jsonobj.streamevent+"_reconnect";
                } else {
                    gaaction = jsonobj.streamevent;
                }
                if(typeof jsonobj.extendederrordetail != 'undefined') {
                    galabel = galabel + "_" + jsonobj.extendederrordetail.replace("0x", "");
                }
            } else {
                gaaction = "Exit Reason";
                galabel = jsonobj.streamevent;
                if(typeof jsonobj.extendederrordetail != 'undefined') {
                    galabel = galabel + "_" + jsonobj.eventdata + "_" + jsonobj.extendederrordetail.replace("0x", "");
                }
            }
        } else {
            sendgadata = false;
        }

        //Send google analytics tracking data
        if(sendgadata == true) {
            sendGAEventMessage(gacategory, gaaction, galabel, gavalue);
        }

        //Send gamepad data for sessions with no gamepad connected
        if((jsonobj.streamevent.localeCompare("nvb_evt_game_connected") == 0) && !_gamepadEventReceived) {
            sendGAEventMessage("Streaming", "Gamepad", "Gamepad Disconnected", 0);
        }

        // Start duration is the first time streamer is connected, ignore game_connected event during reconnection
        if( !_reconnectIssued && jsonobj.streamevent.localeCompare("nvb_evt_game_connected") == 0)
        {
            var streamingStartDuration = _streamingStartTime - _onInitTime;
            sendGATimingEventMessage("Streaming", "Start Duration", streamingStartDuration);

            var streamingStartParams = {
                "type": "streaming_start_time",
                "time": _streamingStartTime.toString()
            };
            PLATFORM.sendMessage(streamingStartParams);
        }

    }
    
    function sendGATimingEventMessage(category, variable, value) {
        var gadataObj = {};
        gadataObj["category"] = category;
        gadataObj["variable"] = variable;
        gadataObj["value"] = value;
        // summary stats is received for every second. Product of summary stats count and framerate
        // gives the approximate number of frames that was received.
        gadataObj["framecount"] = _summaryStatsCount * _frameRate;
        
        PLATFORM.sendMessage({
            type: 'ga_timing_event',
            data: gadataObj
        });
    }
    
    function sendGAEventMessage(category, action, label, value) {
        var gadataObj = {};
        gadataObj["category"] = category;
        gadataObj["action"] = action;
        gadataObj["label"] = label;
        gadataObj["value"] = value;
        // summary stats is received for every second. Product of summary stats count and framerate
        // gives the approximate number of frames that was received.
        gadataObj["framecount"] = _summaryStatsCount * _frameRate;
        _log("GA event : " + JSON.stringify(gadataObj));
        
        PLATFORM.sendMessage({
            type: 'ga_event',
            data: gadataObj
        });
    }

    /*!
     * \brief
     * handle an analytics event from GRID Pepper Module,
     * \param jsonobj the event data.
     */
    function _onAnalyticsEvent(jsonobj) {
        if(jsonobj.customDimensions) {
            // Need to decode the custom dimension name into something we understand
            for( i in jsonobj.customDimensions ) {
                if( jsonobj.customDimensions[i].name == "ClientNATType" )
                {
                    PLATFORM.sendMessage({
                        type: GA_CUSTOM_DIMENSION_TYPE,
                        data: { clientnattype : jsonobj.customDimensions[i].value }
                    });
                }
                else if( jsonobj.customDimensions[i].name == "ServerNATType" ) {
                    PLATFORM.sendMessage({
                        type: GA_CUSTOM_DIMENSION_TYPE,
                        data: { servernattype : jsonobj.customDimensions[i].value }
                    });
                }
                else {
                    // not recognized
                    _log("_onAnalyticsEvent: unrecognized custom dimension: " + jsonobj.customDimensions[i].name );
                }
            }
        }

        sendGAEventMessage( jsonobj.category, jsonobj.action, jsonobj.label, 0 );
    }
    
    /*!
     * \brief
     * handling command response event update from GRID Pepper Module,
     * invoked when the GRID Pepper Module has responsed to the command.
     * \param jsonobj the event itself.
     */
    function _onCommandResponse(jsonobj) {
        if (jsonobj.commandresponseevent) {
            _isRequestInProgress = false;
            var commandresponsetype = jsonobj.commandresponseevent;
            var jsCallAction;
            var jsCallLabel = "nvb_r_success";
            if (commandresponsetype.localeCompare("initialize_completed") == 0) {
                _listener.onInitialized(jsonobj.clientuniqueid);
                jsCallAction = "pInitialize";
            } else if (commandresponsetype.localeCompare("setauthinfo_completed") == 0) {
                jsCallAction = "pSetAuthInfo";
            } else if (commandresponsetype.localeCompare("registercallbacks_completed") == 0) {
                jsCallAction = "pRegisterCallbacks";
            } else if (commandresponsetype.localeCompare("getapplist_success") == 0) {
                _listener.onAppListSuccess(jsonobj);
                jsCallAction = "pGetAppList";
            } else if (commandresponsetype.localeCompare("network_capability_result") == 0) {
                _listener.onNetworkCapabilityResult(jsonobj);
                jsCallAction = "pCheckNetworkCapability";
                jsCallLabel = commandresponsetype.testResult;
                jsCallLabel = jsCallLabel.toLowerCase();
            } else if (commandresponsetype.localeCompare("play_completed") == 0) {
                jsCallAction = "pStart";
            } else if (commandresponsetype.localeCompare("stop_completed") == 0) {
                jsCallAction = "pStop";
            } else if (commandresponsetype.localeCompare("reconnect_completed") == 0) {
                jsCallAction = "pReconnect";
            }

            //Send google analytics tracking data
            if(jsCallAction) {
                sendGAEventMessage("JavaScript Calls", jsCallAction, jsCallLabel, 0);
            }
        }
    }
    /*!
     * \brief
     * handling exception event received from GRID Pepper Module,
     * invoked when the GRID Pepper Module has raised an exception.
     * \param jsonobj the event itself.
     */
    function _onException(jsonobj) {
        if (jsonobj.exceptionevent) {
            _log("Backtrace:\n" + jsonobj.backtrace);
            _listener.onException(jsonobj.backtrace);
        }
    }
    /*!
     * \brief
     * interface to initialize the GRID Pepper Module.
     * \param gridPepperModule the reference to loaded GRID Pepper Module plugin.
     * \param streamerConfig the configuration used to initialize GRID Pepper Module.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     * \note the ui controller should call getter defaultStreamerConfig to get the default
     * streamer configs. The outer layer is responsible to combine their ui configs
     * and hidden configs into one and pass it back in grid.js
     */
    function pInitialize(gridPepperModule, streamerConfig) {
        _onInitTime = new Date();

        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        if(typeof(streamerConfig.gameTitle) != 'undefined') {
            PLATFORM.sendMessage({
                type: 'game_title',
                msg: streamerConfig.gameTitle
            });
        }
        
        PLATFORM.sendMessage({
            type: 'session_id',
            msg: streamerConfig.sessionid
        });

        _sendSystemInfoToAsyncService();

        //check webgl availability
        if(typeof WEBGL != 'undefined') {
            webGlCheckResult = WEBGL.check();
            if(webGlCheckResult != "") {
                var jsonobj = {
                    "version"     : 1.0,
                    "streamevent" : "nvb_initialize_failed",
                    "eventdata"   : webGlCheckResult
                };
                _updateStreamEventStatus(jsonobj);
                return;
            }
        }

        if (!gridPepperModule) {
           _log("Unable to initialize GRID, please pass in a valid gridPepperModule.");
           return;
        }
        _gridPepperModule = gridPepperModule;

        _log("UserAgent: " + window.navigator.userAgent);
        _log("AppVersion: " + window.navigator.appVersion);

        if(streamerConfig.newinstall === true)
        {
            _log("New Installation: " + streamerConfig.userid);
            sendGAEventMessage("New Installation", "NA", "NA", 0);
        }

        _sendMiscInfoToGoogleAnalytics();
        _sendNetworkInfoToGoogleAnalytics();
         
        if(streamerConfig.decodetype == 3)
        {
            var appVersion = window.navigator.appVersion;
            var chromeMajorVersion = parseInt(appVersion.match(/Chrome\/(\d+)\./)[1], 10);
            // enable hw decode by default on Win 8.1 OS and Chrome version > 42 where low latency flag is enabled.
            // appVersion comes as Windows NT 6.3 for Win 8.1, Windows NT 6.2 for Win 8 and so on.
            if ( chromeMajorVersion > 41 && appVersion.search(/Windows NT 6.3/) != -1 )
            {
                streamerConfig.decodetype = 0;
            }
            else
            {
                streamerConfig.decodetype = 1;
            }
        }
        // If running on Win10, use a larger buffer in the AudioRenderer
        // as Win10 has additional jitter in callbacks
        var appVersion = window.navigator.appVersion;
        if(appVersion.search(/Windows NT 10.0/) != -1)
        {
            _log("Using extended audio buffer");
            streamerConfig.useextendedaudiobuffer = true;
        }
        else
        {
            streamerConfig.useextendedaudiobuffer = false;
        }

        _frameRate = streamerConfig.framerate;

        var connectionStr = {
            "version": 1.0,
            "command": "initialize",
            "changestreaming": streamerConfig
        };

        _log("Initializing the client: " + JSON.stringify(streamerConfig));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        return "pending";
    }
    /*!
     * \brief
     * interface to start the client.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     * \param startConfig the configuration used in launching an application, this is optional
     */
    function pStart(startConfig) {
        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        var startC = startConfig || {"command":"start"};
        var connectionStr = {
            "version": 1.0,
            "command": "start",
            "changestreaming": startC
        };

        _summaryStatsCount = 0;
        
        _log("Starting client: " + JSON.stringify(connectionStr));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        return "pending";
    }
    /*!
     * \brief
     * interface to stop the client.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     */
    function pStop() {
        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        var connectionStr = {
            "version": 1.0,
            "command": "stop"
        };

        _log("Stoping client: " + JSON.stringify(connectionStr));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        _reconnectIssued = false;
        
        if( _streamingStartTime != null )
        {
            _streamingEndTime = new Date();
            var streamingEndParams = {
                "type": "streaming_end_time",
                "time": _streamingEndTime.toString()
            };
            PLATFORM.sendMessage(streamingEndParams);
            
            _streamingStartTime = null;
            _streamingEndTime = null;
        }
        
        return "pending";
    }
    /*!
     * \brief
     * get the app list.
     * pGetAppList call is optional.
     * It can be used to get the appid/gameid of the application to be launched if that is not known beforehand.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     */
    function pGetAppList() {
        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        var connectionStr = {
            "version" : 1.0,
            "command": "applist"
        };

        _log("Getting Applist: " + JSON.stringify(connectionStr));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        return "pending";
    }
    /*!
     * \brief
     * handling all the messages from GRID Pepper Module
     * \param message the json object sent from GRID Pepper Module
     */
    function pHandleMessage(message) {
        try {
            var jsonobj = JSON.parse(message.data);
            if (jsonobj) {
                if (jsonobj.version && (jsonobj.version == 1.0)) {
                    if (jsonobj["loadevent"]) {
                        _updateLoadEventStatus(jsonobj);
                    } else if (jsonobj["streamevent"]) {
                        _updateStreamEventStatus(jsonobj);
                    } else if (jsonobj["logevent"]) {
                        _log(jsonobj.logevent);
                    } else if (jsonobj["commandresponseevent"]) {
                        _onCommandResponse(jsonobj);
                    } else if (jsonobj["analytics"]) {
                        _onAnalyticsEvent(jsonobj);
                    } else if (jsonobj["exceptionevent"]) {
                        //Send abort message to GPM
                        var abortStr = {
                            "version": 1.0,
                            "command": "abort"
                        };
                        _gridPepperModule.postMessage(JSON.stringify(abortStr));
                        
                        _onException(jsonobj);
                    } else {
                        _log("The received json object is neither loadevent nor streamevent ");
                    }
                } else {
                    _log("Error: The received message version is not 1.0");
                }
            } else {
                _log("The received message is not json format");
            }
        } catch (err) {
            _log("error: " + err + " " + message.data);
        }
    }
    /*!
     * \brief
     * interface to attach all the listeners.
     */
    function pSetListener(listener) {
        _listener.onLoadEvent = listener.onLoadEvent || _listener.onLoadEvent;
        _listener.onQueuePositionChanged = listener.onQueuePositionChanged || _listener.onQueuePositionChanged;
        _listener.onStreamEvent = listener.onStreamEvent || _listener.onStreamEvent;
        _listener.onInitialized = listener.onInitialized || _listener.onInitialized;
        _listener.onLog = listener.onLog || _listener.onLog;
        _listener.onAppListSuccess = listener.onAppListSuccess || _listener.onAppListSuccess;
        _listener.onNetworkCapabilityResult = listener.onNetworkCapabilityResult || _listener.onNetworkCapabilityResult;
        _listener.onException = listener.onException || _listener.onException;
        if(typeof dvs_changelist != 'undefined') {
            _log( "DVS_CHANGELIST: " + dvs_changelist);
        }
    }

    /*!
     * \brief
     * Controls sending input events to the server.
     * \param boolean enableInputEvents - allows sending all the input events to server
     * \param boolean mouselock - allows lock/unlock of the mouse.
     * \note this method has to be called in the context of user action to lock the mouse
     */
    function pControlInputEvents( enableInputEvents , mouselock )
    {
        var connectionStr = {
            "version": 1.0,
            "command": "controlInputEvents",
            "changestreaming": {
                "enableInputEvents": enableInputEvents,
                "mouselock": mouselock
            }
        };
        _log("change mouse state: " + JSON.stringify(connectionStr));
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
    }

    /*!
     * \brief
     * Check the network capability.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     */
    function pCheckNetworkCapability() {
        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        var connectionStr = {
            "version": 1.0,
            "command": "checknetworkcapability"
        };

        _log("Checking network capability: " + JSON.stringify(connectionStr));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        return "pending";
    }

    /*!
     * \brief
     * interface to reconnect to the server.
     * \return request_in_progress_error, if there is already a request in progress.
     *         pending, otherwise.
     */
    function pReconnect() {
        if(_isRequestInProgress)
        {
            return "request_in_progress_error";
        }

        var connectionStr = {
            "version": 1.0,
            "command": "reconnect"
        };

        _log("Trying to reconnect to the server: " + JSON.stringify(connectionStr));
        _isRequestInProgress = true;
        _gridPepperModule.postMessage(JSON.stringify(connectionStr));
        _reconnectIssued = true;
        return "pending";
    }
    return {
        /*!
         * \brief
         * The below methods must be called in order
         * Note: initialize, getAppList, checkNetworkCapability, start and stop should not be called simultaneously.
         *       If a simultaneous request is made, then it will fail with an error - request_in_progress_error.
         */
        setListener:              pSetListener,               /*!< attach the UI listeners to listen to GRID Pepper Module */
        handleMessage:            pHandleMessage,             /*!< this handler must be attached to the parent div in which GridPepperModule embed tag is loaded */
        defaultStreamerConfig:    pDefaultStreamerConfig,     /*!< Deprecated. streamerConfig is needed to call initialize */
        defaultInitializeConfig:  pDefaultInitializeConfig,   /*!< Initialize config is needed to call initialize */
        initialize:               pInitialize,                /*!< initialize the GridPepperModule, this should happen after the GridPepperModule is loaded */
        getAppList:               pGetAppList,                /*!< get the application list to decide which application to launch, this is optional */
        checkNetworkCapability:   pCheckNetworkCapability,    /*!< Check the network capability, this is optional */
        defaultStartConfig:       pDefaultStartConfig,        /*!< startConfig is needed to call start, this is optional */
        start:                    pStart,                     /*!< start the client, this should happen after GridPepperModule is initialized */
        controlInputEvents:       pControlInputEvents,        /*!< Controls sending input events to the server and allowing mouse to be caputred or released. To Lock/unlock Mouse this function can only be called when gridpeppermodule has focus and in response to an input event */
        stop:                     pStop,                      /*!< stop the client */
        reconnect:                pReconnect,                 /*!< Attempts to reconnect to the server. Should be called if streaming is interrupted by streamer network error */
    };
})();
var dvs_changelist = 21707578;
